"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ==== Appearance
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set cursorline "highlight current line

colorscheme jellybeans

set hlsearch "highlight search results
" Disable highlight when <leader>. is pressed
map <silent> <leader>. :noh<cr>

" ================= GUI setup =========================
if has('gui_running')
	set guifont=Source_Code_Pro:h13
	" In MacVim, you can have multiple tabs open. This mapping makes Ctrl-Tab
	" switch between them, like browser tabs. Ctrl-Shift-Tab goes the other way.
	noremap <C-Tab> :tabnext<CR>
	noremap <C-S-Tab> :tabprev<CR>

	" Switch to specific tab numbers with Command-number
	noremap <D-1> :tabn 1<CR>
	noremap <D-2> :tabn 2<CR>
	noremap <D-3> :tabn 3<CR>
	noremap <D-4> :tabn 4<CR>
	noremap <D-5> :tabn 5<CR>
	noremap <D-6> :tabn 6<CR>
	noremap <D-7> :tabn 7<CR>
	noremap <D-8> :tabn 8<CR>
	noremap <D-9> :tabn 9<CR>
	" Command-0 goes to the last tab
	noremap <D-0> :tablast<CR>
endif

" ================ Statusline =========================
" from https://github.com/spf13/spf13-vim/blob/master/.vimrc
" " %< truncation point
" \ space
" %f relative path to file
" %m modified flag [+] (modified), [-] (unmodifiable) or nothing
" %r readonly flag [RO]
" %y filetype [ruby]
" %= split point for left and right justification
" %-14.( %) block of fixed width 14 characters
" %l current line
" %c current column
" %V current virtual column as -{num} if different from %c
" %P percentage through buffer
if has('statusline')
	set laststatus=2
	" Broken down into easily includeable segments
	set statusline=%<%f\ " Filename
	set statusline+=%w%h%m%r " Options
	set statusline+=%{fugitive#statusline()} " Git Hotness
	set statusline+=\ [%{&ff}/%Y] " filetype
	set statusline+=\ [%{getcwd()}] " current dir
	set statusline+=%#warningmsg#
	set statusline+=%{SyntasticStatuslineFlag()}
	set statusline+=%*
	let g:syntastic_enable_signs=1
	set statusline+=%=%-14.(%l,%c%V%)\ %p%% " Right aligned file nav info
endif

" =============== Showmarks =========================
let g:showmarks_enable = 1 "always show showmarks
let showmarks_include = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
" Ignore help, quickfix, non-modifiable buffers
let showmarks_ignore_type = "hqm"


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ==== Functionality/Behaviour
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" =============== Splits =========================
nmap vv :vsplit<cr><C-w>l

" Create a split on the given side.
" From http://technotales.wordpress.com/2010/04/29/vim-splits-a-guide-to-doing-exactly-what-you-want/
nmap <leader><left> :leftabove vsp<CR>
nmap <leader><right> :rightbelow vsp<CR>
nmap <leader><up> :leftabove sp<CR>
nmap <leader><down> :rightbelow sp<CR>


" ============== Indentation =========================
set softtabstop=4 tabstop=4 shiftwidth=4 noexpandtab " should give me tabs instead of spaces. Reformat with =
set clipboard=autoselect
set smartindent "Smart indent
set wrap "Wrap lines
" set nowrap "Don't wrap lines
set linebreak "Wrap lines at convenient points


" ================ Persistent Undo ==================
" Keep undo history across sessions, by storing in file.
" Only works all the time.
if has('persistent_undo')
	silent !mkdir ~/.vim/backups > /dev/null 2>&1
	set undodir=~/.vim/backups
	set undofile
endif


" ============ History =========================
set history=1000


" ============ Completion =========================
set wildmenu "show completion menu
set wildmode=list:longest "complete up to the point where it's ambiguous


" ============ Spell Checking =========================
" Pressing ,ss will toggle and untoggle spell checking
map <leader>ss :setlocal spell!<cr>

" Shortcuts using <leader>
map <leader>sn ]s
map <leader>sp [s
map <leader>sa zg
map <leader>s? z=


" =========== Folds =========================
set foldmethod=syntax
"unfold everything on opening file
au BufRead * normal zR
set foldnestmax=3 "deepest fold is 3 levels
set nofoldenable "dont fold by default

" set complete+=k " enable dictionary completion
"highlight clear SpellBad "No funky spelling correction wriggles


" ========= Invisibles =========================
" set listchars=trail:.,tab:>-,eol:$
" set listchars=tab:│┈,trail:·,extends:>,precedes:<,nbsp:&
" set listchars=trail:.,tab:>-,eol:$
set listchars=tab:│\ ,trail:·,extends:>,precedes:<,nbsp:&
noremap <Leader>i :set list!<CR> " Toggle invisible chars


" ============ Scrolling =========================
"up by 3 lines
nnoremap <C-e> 3<C-e> 
"down by 3 lines
nnoremap <C-y> 3<C-y> 
set scrolloff=8 "start scrolling 8 lines from the bottom

" ========= Misc =========================

"autosave when losing focusresults
autocmd BufLeave,FocusLost * silent! wall 

" No annoying sound on errors
set noerrorbells
set novisualbell
set vb t_vb=
set tm=500


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ==== Keymap Shortcuts
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" remap ESC
inoremap jj <ESC>
inoremap jk <ESC>

" Quicker command mode
nnoremap ; :

"map F1 to esc instead of help because that's fucking annoying
map <F1> <Esc>
imap <F1> <Esc>

" map <F13><F14><F15>
nmap <F13> ciw
nmap <F14> ci"
nmap <F15> <Plug>CommentaryLine

" Remap VIM 0 to first non-blank character
map 0 ^

" Make cursor move by visual lines instead of file lines (when wrapping)
map <up> gk
map k gk
imap <up> <C-o>gk
map <down> gj
map j gj
imap <down> <C-o>gj
map E ge

" Camelcase Motion
nmap W <Plug>CamelCaseMotion_w
nmap B <Plug>CamelCaseMotion_b
nmap E <Plug>CamelCaseMotion_e


" ========= Tabs =========================
" Tab/shift-tab to indent/outdent in visual mode.
vnoremap <Tab> >gv
vnoremap <S-Tab> <gv

" Keep selection when indenting/outdenting.
vnoremap > >gv
vnoremap < <gv


" ========== Surround =========================
" ," Surround a word with "quotes"
map ," ysiw"
vmap ," c"<C-R>""<ESC>

" ,' Surround a word with 'single quotes'
map ,' ysiw'
vmap ,' c'<C-R>"'<ESC>

" ,) or ,( Surround a word with (parens)
" The difference is in whether a space is put in
map ,( ysiw(
map ,) ysiw)
vmap ,( c( <C-R>" )<ESC>
vmap ,) c(<C-R>")<ESC>

" ,[ Surround a word with [brackets]
map ,] ysiw]
map ,[ ysiw[
vmap ,[ c[ <C-R>" ]<ESC>
vmap ,] c[<C-R>"]<ESC>

" ,{ Surround a word with {braces}
map ,} ysiw}
map ,{ ysiw{
vmap ,} c{ <C-R>" }<ESC>
vmap ,{ c{<C-R>"}<ESC>

" when selected, pressing '"' surrounds the selection with "". Like textmate
xmap " S"

" paste in line above
nmap <leader>P O<Esc>p
" and below
nmap <leader>p o<Esc>p

" ========================= Textmate-like keymaps =========================

" awesome, inserts new line without going into insert mode
map <S-Enter> O<ESC>0100x
map <Enter> o<ESC>0100x

" ctrl+enter = new line underneath in insert mode - (nearly) like textmate
imap <C-Enter> <ESC>o

" Move a line of text using ALT+[jk] or Command+[jk] on mac
nmap <M-j> mz:m+<cr>`z
nmap <M-k> mz:m-2<cr>`z
vmap <M-j> :m'>+<cr>`<my`>mzgv`yo`z
vmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`z
if has("mac") || has("macunix")
	nmap <D-j> <M-j>
	nmap <D-k> <M-k>
	vmap <D-j> <M-j>
	vmap <D-k> <M-k>
endif

" " command+/ comments/uncomments line. Just like in Textmate. Nice
" In visual mode it comments the whole block
nmap <D-/> <Plug>CommentaryLine
xmap <D-/> <Plug>Commentary


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Misc
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Remove the Windows ^M - when the encodings gets messed up
noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm


" Save a file as root.
cabbrev w!! w !sudo tee % > /dev/null<CR>:e!<CR><CR>

" Ruby stuff
" Insert HashRockets... :)
imap <C-l> <Space>=><Space>

" Alignment
map <Leader>l :Tabularize<space>

set fileformat=unix
set fileformats=unix,dos

filetype indent on


" ============== Filetype mappings =========================
au BufRead,BufNewFile *.{html,htm,js} set ft=html.javascript
au BufRead,BufNewFile {Gemfile,Rakefile,Vagrantfile,Thorfile,config.ru} set ft=ruby
